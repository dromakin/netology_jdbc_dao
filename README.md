# Задача «Слой DAO (Data Access Object)»

## Описание

Попрактикуемся в работе со Spring JDBC, параллельно закрепляя уже пройденные темы.

Вам надо написать приложение для работы с БД, используя скрипты, которые вы написали при выполнении [второго задания](../../sql-agg/task/README.md).

**Шаг 1.** Создайте Spring Boot приложение с зависимостями на два стартера — `spring-boot-starter-jdbc` и `spring-boot-starter-web`.

**Шаг 2.** Перенесите скрипт создания таблицы в файл `schema.sql`, чтобы Spring Boot автоматически создавал таблицу.

**Шаг 3.** Перенесите скрипт запроса из второго задания в папку `resources`. Перепишите скрипт так, чтобы он возвращал `product_name` для именованного параметра `name`(а не только для `alexey`), который вы будете передавать в методы выполнения скрипта `NamedParameterJdbcTemplate` вместе со скриптом запроса.

**Шаг 4.** Напишите репозиторий для работы с БД.

- Создайте класс и пометьте его аннотацией Repository, либо создайте бин репозитория в Java Config классе.
- Добавьте в поле класса String, которое содержит ваше содержание вашего скрипта. Само содержание вы можете считать с помощью кода ниже. Вам надо будет передать в метод `read` название вашего скрипта, который лежит в папке `resources`. Например так: `read(myScript.sql)`.
- Создайте метод `getProductName(String name)`, который будет принимать имя и возвращать название продукта из базы данных.

```java
private static String read(String scriptFileName) {
        try (InputStream is = new ClassPathResource(scriptFileName).getInputStream();
             BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(is))) {
            return bufferedReader.lines().collect(Collectors.joining("\n"));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
``` 

**Шаг 5.** Напишите контроллер с методом-обработчиком GET-метода запроса с маппингом на endpoint `/products/fetch-product`. В query params запроса будет приходить строковый параметр `name`, который вам надо будет передавать дальше в репозиторий. То есть, ваш метод должен уметь обрабатывать запрос вида `localhost:8080/products/fetch-product?name=Ivan`.
Контроллер должен будет возвращать название продукта, которое он получит от репозитория.

**Шаг 6**. Написанный код выложите в отдельный репозиторий на GitHub и прикрепите ссылку на него в комментарий к домашнему заданию.

# Задача «Миграции*» (задача со звёздочкой)

## Описание

Эта задача необязательная, её выполнение не влияет на получение зачёта.

Настало время попрактиковаться в работе с механизмами миграции.

**Что нужно сделать**

1. Необходимо переписать логику работы задания [«Слой DAO (Data Access Object)»](../task1/README.md) так, чтобы ваше приложение работало с миграциями. Не важно, выберете вы Flyway или Liquibase.

2. Написанный код выложите в отдельный репозиторий на GitHub и прикрепите ссылку на него в комментарий к домашнему заданию.

# Задача «Две таблицы с Hibernate*» (задача со звёздочкой)

## Описание

Эта задача необязательная, её выполнение не влияет на получение зачёта.

Перепишем приложение из [задания по JDBC](../../jdbc/task1/README.md) на Hibernate.

1. Нужно написать две `Entity`, соответствующие двум таблицам из задания. Учтите, что вам надо верно выбрать логику отношений этих `Entity`: `OneToOne`, `OneToMany`, `ManyToOne`, `ManyToMany`.

2. Перепишите репозиторий, чтобы он работал с `EntityManager`, а не через `NamedParameterJdbcTemplate`.

3. Написанный код выложите в тот же репозиторий, что и для задачи [«Слой DAO (Data Access Object)»](../../jdbc/task1/README.md) на GitHub, только создайте под него другую ветку `hibernate` и прикрепите ссылку на неё в комментарий к домашнему заданию.
